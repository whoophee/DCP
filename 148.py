# This problem was asked by Apple.
# Gray code is a binary code where each successive value differ in only one bit,
# as well as when wrapping around. Gray code is common in hardware so that we don't
# see temporary spurious values during transitions.
# Given a number of bits n, generate a possible gray code for it.
# For example, for n = 2, one gray code would be [00, 01, 11, 10].
####
# The idea behind generating this sequence is pretty simple.
# 1. Generate this sequence for n-1 bits.
# 2. Add a '0' to the end of each element of the n-1 bit gray code
# 3. Add a '1' to the end of each element of a reversed n-1 bit gray code
# 4. Concatenate the two arrays
# Here, since the leading bit changes at the middlemost indices of the generated
# array, and the rest consists of the reverse, there is perfect continuity between
# whatever pattern was generated by the n-1 bit gray code.
# When this is stopped at n=1, a perfect recursive subproblem is created.
# Caching this would make it DPish and result in lesser time for successive calls.
def gray_code(n):
    if n == 1:
        return ['0', '1']
    tmp = gray_code(n-1)
    return ['0'+x for x in tmp] + ['1'+x for x in reversed(tmp)]
####
print(gray_code(2))
print(gray_code(3))
